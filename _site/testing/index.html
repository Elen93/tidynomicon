<html>
  <head>
    <title>Testing</title>
    <link rel="stylesheet" href="/css/bootstrap.min.css" />
    <link rel="stylesheet" href="/css/tango.css" />
    <link rel="stylesheet" href="/css/site.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" async></script>
    <script src="/js/jquery.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
  </head>
  <body>
    <h1>Testing</h1>

    

    <p>Mistakes were made in <a href="../cleanup/">the previous tutorial</a>.
It would be hubris to believe that we will not make more as we continue to clean this data.
What will guide us safely through these dark caverns and back into the light of day?</p>

<p>The answer is testing.
We must test our assumptions, test our code, test our very <em>being</em> if we are to advance.
Luckily for us,
R provides tools for this purpose not unlike those available in Python.</p>

<h2 id="the-problem">The Problem</h2>

<p>We have been given several more CSV files to clean up.
The first,
<code class="highlighter-rouge">raw/at_health_facilities.csv</code>,
shows the percentage of births at health facilities by country, year, and mother’s age.
It comes from the same UNICEF website as our previous data,
but has a different set of problems.
Here are its first few lines:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>,,GLOBAL DATABASES,,,,,,,,,,,,,
,,[data.unicef.org],,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
Indicator:,Delivered in health facilities,,,,,,,,,,,,,,
Unit:,Percentage,,,,,,,,,,,,,,
,,,,Mother's age,,,,,,,,,,,
iso3,Country/areas,year,Total ,age 15-17,age 18-19,age less than 20,age more than 20,age 20-34,age 35-49,Source,Source year,,,,
AFG,Afghanistan,2010, 	33 , 	25 , 	29 , 	28 , 	31 , 	31 , 	31 ,MICS,2010,,,,
ALB,Albania,2005, 	98 , 	100 , 	96 , 	97 , 	98 , 	99 , 	92 ,MICS,2005,,,,
ALB,Albania,2008, 	98 , 	94 , 	98 , 	97 , 	98 , 	98 , 	99 ,DHS,2008,,,,
...
</code></pre></div></div>

<p>and its last:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ZWE,Zimbabwe,2005, 	66 , 	64 , 	64 , 	64 , 	67 , 	69 , 	53 ,DHS,2005,,,,
ZWE,Zimbabwe,2009, 	58 , 	49 , 	59 , 	55 , 	59 , 	60 , 	52 ,MICS,2009,,,,
ZWE,Zimbabwe,2010, 	64 , 	56 , 	66 , 	62 , 	64 , 	65 , 	60 ,DHS,2010,,,,
ZWE,Zimbabwe,2014, 	80 , 	82 , 	82 , 	82 , 	79 , 	80 , 	77 ,MICS,2014,,,,
,,,,,,,,,,,,,,,
Definition:,Percentage of births delivered in a health facility.,,,,,,,,,,,,,,
,"The indicator refers to women who had a live birth in a recent time period, generally two years for MICS and five years for DHS.",,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
Note:,"Database include reanalyzed data from DHS and MICS, using a reference period of two years before the survey.",,,,,,,,,,,,,,
,Includes surveys which microdata were available as of April 2016. ,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
Source:,"UNICEF global databases 2016 based on DHS, MICS .",,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
Contact us:,data@unicef.org,,,,,,,,,,,,,,
</code></pre></div></div>

<p>There are three files in this collection,
all exported from the same Excel spreadsheet.
Rather than writing a separate script for each,
we should create a tool that will handle them all.
At first glance,
the problems we need to solve to do this are:</p>

<ol>
  <li>Each file may contain a different number of records,
so our tool should select rows by content rather than by absolute row number.</li>
  <li>Each file may contain a different set of columns,
so our tool should select those that always appear by name
and somehow infer the location of the rest.</li>
</ol>

<p>These two requirements will make our program significantly more complicated,
so we should tackle each with its own testable function.</p>

<h2 id="testing">Testing</h2>

<p>The standard testing library for R is <a href="https://github.com/r-lib/testthat">testthat</a>.
Like Python’s <a href="https://docs.python.org/3/library/unittest.html">unittest</a> library,
it is a member of the <a href="https://en.wikipedia.org/wiki/XUnit">xUnit</a> family of testing libraries:</p>

<ol>
  <li>Each test consists of a single function that tests a single property or behavior of the system.</li>
  <li>Tests are collected into files with prescribed names that can be found by a <em>test runner</em>.</li>
  <li>Shared setup and teardown operations are put in functions of their own.</li>
</ol>

<p>Let’s load it and write our first test:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">testthat</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
## Attaching package: 'testthat'
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## The following object is masked from 'package:dplyr':
## 
##     matches
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## The following object is masked from 'package:purrr':
## 
##     is_null
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test_that</span><span class="p">(</span><span class="s2">"Zero equals itself"</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">expect_equal</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>As is conventional with xUnit-style testing libraries,
no news is good news:
if a test passes,
it doesn’t produce output because it doesn’t need our attention.
Let’s try something that ought to fail:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test_that</span><span class="p">(</span><span class="s2">"Zero equals one"</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">expect_equal</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Error: Test failed: 'Zero equals one'
## * 0 not equal to 1.
## 1/1 mismatches
## [1] 0 - 1 == -1
</code></pre></div></div>

<p>Good:
we can draw some comfort from the fact that They have not yet changed the fundamental rules of arithmetic.
But what are the curly braces around <code class="highlighter-rouge">expect_equal</code> for?
The answer is that they create a code block of some sort for <code class="highlighter-rouge">test_that</code> to run.
We can run <code class="highlighter-rouge">expect_equal</code> on its own:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">expect_equal</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Error: 0 not equal to 1.
## 1/1 mismatches
## [1] 0 - 1 == -1
</code></pre></div></div>

<p>but that doesn’t produce a summary of how many tests passed or failed.
Passing a block of code to <code class="highlighter-rouge">test_that</code> also allows us to check several things in one test:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test_that</span><span class="p">(</span><span class="s2">"Testing two things"</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Error: Test failed: 'Testing two things'
## * 0 not equal to 1.
## 1/1 mismatches
## [1] 0 - 1 == -1
</code></pre></div></div>

<p>Note that a block of code is <em>not</em> the same thing as an anonymous function,
which is why running this block of code does nothing:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test_that</span><span class="p">(</span><span class="s2">"Using an anonymous function"</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(){</span><span class="w">
  </span><span class="n">print</span><span class="p">(</span><span class="s2">"In our anonymous function"</span><span class="p">)</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>But running blocks of tests by hand is a bad practice no matter what is in them.
What we should do instead is put related tests in files,
then put those files in a directory called <code class="highlighter-rouge">tests</code>.
We can then run some or all of those tests with a single command.</p>

<p>To start,
let’s create <code class="highlighter-rouge">tests/test_example.R</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">testthat</span><span class="p">)</span><span class="w">
</span><span class="n">context</span><span class="p">(</span><span class="s2">"Demonstrating the testing library"</span><span class="p">)</span><span class="w">

</span><span class="n">test_that</span><span class="p">(</span><span class="s2">"Testing a number with itself"</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="m">-1</span><span class="p">)</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="kc">Inf</span><span class="p">,</span><span class="w"> </span><span class="kc">Inf</span><span class="p">)</span><span class="w">
</span><span class="p">})</span><span class="w">

</span><span class="n">test_that</span><span class="p">(</span><span class="s2">"Testing different numbers"</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="p">})</span><span class="w">

</span><span class="n">test_that</span><span class="p">(</span><span class="s2">"Testing with a tolerance"</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0.01</span><span class="p">,</span><span class="w"> </span><span class="n">tolerance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.05</span><span class="p">,</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0.01</span><span class="p">,</span><span class="w"> </span><span class="n">tolerance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.005</span><span class="p">,</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="p">})</span><span class="w">

</span><span class="n">test_that</span><span class="p">(</span><span class="s2">"Testing character vectors"</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="s2">"abc"</span><span class="p">,</span><span class="w"> </span><span class="s2">"XYZ"</span><span class="p">)</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="s2">"abc"</span><span class="p">,</span><span class="w"> </span><span class="s2">"ABC"</span><span class="p">)</span><span class="w">
</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>The first line loads the testthat package,
which gives us our tools.
The call to <code class="highlighter-rouge">context</code> on the second line gives this set of tests a name for reporting purposes.
After that,
we add as many calls to <code class="highlighter-rouge">test_that</code> as we want,
each with a name and a block of code.
We can now run this file from within RStudio:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test_dir</span><span class="p">(</span><span class="s2">"tests"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## ✔ | OK F W S | Context
## 
⠏ |  0       | Demonstrating the testing library
⠋ |  1       | Demonstrating the testing library
⠙ |  2       | Demonstrating the testing library
⠹ |  3       | Demonstrating the testing library
⠸ |  3 1     | Demonstrating the testing library
⠼ |  4 1     | Demonstrating the testing library
⠴ |  4 2     | Demonstrating the testing library
⠦ |  4 3     | Demonstrating the testing library
⠧ |  4 4     | Demonstrating the testing library
✖ |  4 4     | Demonstrating the testing library
## ───────────────────────────────────────────────────────────────────────────
## test_example.R:11: failure: Testing different numbers
## 0 not equal to 1.
## 1/1 mismatches
## [1] 0 - 1 == -1
## 
## test_example.R:16: failure: Testing with a tolerance
## 0 not equal to 0.01.
## 1/1 mismatches
## [1] 0 - 0.01 == -0.01
## 
## test_example.R:20: failure: Testing character vectors
## "abc" not equal to "XYZ".
## 1/1 mismatches
## x[1]: "abc"
## y[1]: "XYZ"
## 
## test_example.R:21: failure: Testing character vectors
## "abc" not equal to "ABC".
## 1/1 mismatches
## x[1]: "abc"
## y[1]: "ABC"
## ───────────────────────────────────────────────────────────────────────────
## 
⠏ |  0       | Finding empty rows
⠋ |  0 1     | Finding empty rows
⠙ |  0 2     | Finding empty rows
⠹ |  1 2     | Finding empty rows
✖ |  1 2     | Finding empty rows
## ───────────────────────────────────────────────────────────────────────────
## test_find_empty_a.R:9: failure: A single non-empty row is not mistakenly detected
## `result` not equal to NULL.
## Types not compatible: integer is not NULL
## 
## test_find_empty_a.R:14: failure: Half-empty rows are not mistakenly detected
## `result` not equal to NULL.
## Types not compatible: integer is not NULL
## ───────────────────────────────────────────────────────────────────────────
## 
⠏ |  0       | Testing properties of tibbles
⠋ |  1       | Testing properties of tibbles
✔ |  1       | Testing properties of tibbles
## 
## ══ Results ════════════════════════════════════════════════════════════════
## OK:       6
## Failed:   6
## Warnings: 0
## Skipped:  0
</code></pre></div></div>

<p>A bit of care is needed when interpreting these results.
There are four <code class="highlighter-rouge">test_that</code> calls,
but eight actual checks,
and the number of successes and failures is counted by recording the results of the latter,
not the former.</p>

<p>What then is the purpose of <code class="highlighter-rouge">test_that</code>?
Why not just use <code class="highlighter-rouge">expect_equal</code> and its kin,
such as <code class="highlighter-rouge">expect_true</code>, <code class="highlighter-rouge">expect_false</code>, <code class="highlighter-rouge">expect_length</code>, and so on?
The answer is that it allows us to do one operation and then check several things afterward.
Let’s create another file called <code class="highlighter-rouge">tests/test_tibble.R</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">tidyverse</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">testthat</span><span class="p">)</span><span class="w">
</span><span class="n">context</span><span class="p">(</span><span class="s2">"Testing properties of tibbles"</span><span class="p">)</span><span class="w">

</span><span class="n">test_that</span><span class="p">(</span><span class="s2">"Tibble columns are given the name 'value'"</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">as.tibble</span><span class="p">()</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="nf">names</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="w"> </span><span class="s2">"value"</span><span class="p">)</span><span class="w">
</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>(We don’t actually have to call our test files <code class="highlighter-rouge">test_something.R</code>,
but <code class="highlighter-rouge">test_dir</code> and the rest of R’s testing infrastructure expect us to.
Similarly,
we don’t have to put them in a <code class="highlighter-rouge">tests</code> directory,
but gibbering incoherence is likely to ensue if we do not.)
Now let’s run all of our tests:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test_dir</span><span class="p">(</span><span class="s2">"tests"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## ✔ | OK F W S | Context
## 
⠏ |  0       | Demonstrating the testing library
⠋ |  1       | Demonstrating the testing library
⠙ |  2       | Demonstrating the testing library
⠹ |  3       | Demonstrating the testing library
⠸ |  3 1     | Demonstrating the testing library
⠼ |  4 1     | Demonstrating the testing library
⠴ |  4 2     | Demonstrating the testing library
⠦ |  4 3     | Demonstrating the testing library
⠧ |  4 4     | Demonstrating the testing library
✖ |  4 4     | Demonstrating the testing library
## ───────────────────────────────────────────────────────────────────────────
## test_example.R:11: failure: Testing different numbers
## 0 not equal to 1.
## 1/1 mismatches
## [1] 0 - 1 == -1
## 
## test_example.R:16: failure: Testing with a tolerance
## 0 not equal to 0.01.
## 1/1 mismatches
## [1] 0 - 0.01 == -0.01
## 
## test_example.R:20: failure: Testing character vectors
## "abc" not equal to "XYZ".
## 1/1 mismatches
## x[1]: "abc"
## y[1]: "XYZ"
## 
## test_example.R:21: failure: Testing character vectors
## "abc" not equal to "ABC".
## 1/1 mismatches
## x[1]: "abc"
## y[1]: "ABC"
## ───────────────────────────────────────────────────────────────────────────
## 
⠏ |  0       | Finding empty rows
⠋ |  0 1     | Finding empty rows
⠙ |  0 2     | Finding empty rows
⠹ |  1 2     | Finding empty rows
✖ |  1 2     | Finding empty rows
## ───────────────────────────────────────────────────────────────────────────
## test_find_empty_a.R:9: failure: A single non-empty row is not mistakenly detected
## `result` not equal to NULL.
## Types not compatible: integer is not NULL
## 
## test_find_empty_a.R:14: failure: Half-empty rows are not mistakenly detected
## `result` not equal to NULL.
## Types not compatible: integer is not NULL
## ───────────────────────────────────────────────────────────────────────────
## 
⠏ |  0       | Testing properties of tibbles
⠋ |  1       | Testing properties of tibbles
✔ |  1       | Testing properties of tibbles
## 
## ══ Results ════════════════════════════════════════════════════════════════
## OK:       6
## Failed:   6
## Warnings: 0
## Skipped:  0
</code></pre></div></div>

<p>That’s rather a lot of output.
Happily,
we can provide a <code class="highlighter-rouge">filter</code> argument to <code class="highlighter-rouge">test_dir</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test_dir</span><span class="p">(</span><span class="s2">"tests"</span><span class="p">,</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"test_tibble.R"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Error in test_files(paths, reporter = reporter, env = env, stop_on_failure = stop_on_failure, : No matching test file in dir
</code></pre></div></div>

<p>Oh dear.
Oh.
Ah.
It turns out that <code class="highlighter-rouge">filter</code> is applied to filenames <em>after</em> the leading <code class="highlighter-rouge">test_</code> and the trailing <code class="highlighter-rouge">.R</code> have been removed.
Let’s try again:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test_dir</span><span class="p">(</span><span class="s2">"tests"</span><span class="p">,</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"tibble"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## ✔ | OK F W S | Context
## 
⠏ |  0       | Testing properties of tibbles
⠋ |  1       | Testing properties of tibbles
✔ |  1       | Testing properties of tibbles
## 
## ══ Results ════════════════════════════════════════════════════════════════
## OK:       1
## Failed:   0
## Warnings: 0
## Skipped:  0
</code></pre></div></div>

<p>That’s better,
and it illustrates our earlier point about the importance of following conventions.</p>

<h2 id="warming-up">Warming Up</h2>

<p>To give ourselves something to test,
let’s create a file called <code class="highlighter-rouge">scripts/find_empty_01.R</code>
that defines a single function <code class="highlighter-rouge">find_empty_rows</code> that identifies all the empty rows in a CSV file.
Our first implementation is:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">find_empty_rows</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read_csv</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="w">
  </span><span class="n">empty</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
    </span><span class="n">pmap</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">args</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">...</span><span class="p">)</span><span class="w">
      </span><span class="nf">all</span><span class="p">(</span><span class="nf">is.na</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">args</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">""</span><span class="p">))</span><span class="w">
    </span><span class="p">})</span><span class="w">
  </span><span class="n">data</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
    </span><span class="n">transmute</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">row_number</span><span class="p">())</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
    </span><span class="n">filter</span><span class="p">(</span><span class="nf">as.logical</span><span class="p">(</span><span class="n">empty</span><span class="p">))</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
    </span><span class="n">pull</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>This is complex enough to merit line-by-line exegesis:</p>

<ol>
  <li>Define the function with one argument <code class="highlighter-rouge">source</code>, from which we shall read.</li>
  <li>Read tabular data from that source and assign the resulting tibble to <code class="highlighter-rouge">data</code>.</li>
  <li>Begin a pipeline that will assign something to the variable <code class="highlighter-rouge">empty</code>.
    <ol>
      <li>Use <code class="highlighter-rouge">pmap</code> to map a function across each row of the tibble.
Since we don’t know how many columns are in each row,
we use <code class="highlighter-rouge">...</code> to take any number of arguments.</li>
      <li>Convert the variable number of arguments to a list.</li>
      <li>Check to see if all of those arguments are either <code class="highlighter-rouge">NA</code> or the empty string.</li>
      <li>Close the mapped function’s definition.</li>
    </ol>
  </li>
  <li>Start another pipeline.
This one’s result isn’t assigned to a variable,
so whatever it produces will be the value returned by <code class="highlighter-rouge">find_empty_rows</code>.
    <ol>
      <li>Construct a tibble that contains only the row numbers of the original table in a column called <code class="highlighter-rouge">id</code>.</li>
      <li>Filter those row numbers to keep only those corresponding to rows that were entirely empty.
The <code class="highlighter-rouge">as.logical</code> call inside <code class="highlighter-rouge">filter</code> is needed because the value returned by <code class="highlighter-rouge">pmap</code>
(which we stored in <code class="highlighter-rouge">empty</code>)
is a list, not a logical vector.</li>
      <li>Use <code class="highlighter-rouge">pull</code> to get the one column we want from the filtered tibble as a vector.</li>
    </ol>
  </li>
</ol>

<p>There is a lot going on here,
particularly if you are (as I am at the time of writing)
new to R.
But now that we have it,
we can do this:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">tidyverse</span><span class="p">)</span><span class="w">
</span><span class="n">source</span><span class="p">(</span><span class="s2">"scripts/find_empty_01.R"</span><span class="p">)</span><span class="w">
</span><span class="n">find_empty_rows</span><span class="p">(</span><span class="s2">"a,b\n1,2\n,\n5,6"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 2
</code></pre></div></div>

<p>The <code class="highlighter-rouge">source</code> function reads R code from the given source.
Using this inside an RMarkdown file is usually a bad idea,
since the generated HTML or PDF won’t show readers what code we loaded and ran.
On the other hand,
if we are creating command-line tools for use on clusters or in other batch processing modes,
and are careful to display the code in a nearby block,
the stain on our soul is excusable.</p>

<p>The more interesting part of this example is the call to <code class="highlighter-rouge">find_empty_rows</code>.
Instead of giving it the name of a file,
we have given it the text of the CSV we want parsed.
This is then passed to <code class="highlighter-rouge">read_csv</code>,
which (according to documentation that only took us 15 minutes to realize we had already seen)
interprets its first argument as <em>either</em> a filename <em>or</em> the actual text to be parsed
depending on whether it contains a newline character.
This allows us to write put the text fixture
(i.e., the thing on which the test is being run)
right there in the code as a literal string,
which experience shows is to understand and maintain
than having test data in separate files.</p>

<p>Our function seems to work,
but we can make it more pipelinesque:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">find_empty_rows</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">read_csv</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
    </span><span class="n">pmap_lgl</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">args</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">...</span><span class="p">)</span><span class="w">
      </span><span class="nf">all</span><span class="p">(</span><span class="nf">is.na</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">args</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">""</span><span class="p">))</span><span class="w">
    </span><span class="p">})</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
    </span><span class="n">tibble</span><span class="p">(</span><span class="n">empty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">.</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
    </span><span class="n">mutate</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">row_number</span><span class="p">())</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
    </span><span class="n">filter</span><span class="p">(</span><span class="n">empty</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
    </span><span class="n">pull</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Going line by line once again:</p>

<ol>
  <li>Define a function with one argument called <code class="highlighter-rouge">source</code>, from which we shall once again read.</li>
  <li>Read from that source to fill the pipeline.</li>
  <li>Map our test for emptiness across each row, returning a logical vector as a result.
(<code class="highlighter-rouge">pmap_lgl</code> is a derivative of <code class="highlighter-rouge">pmap</code> that always casts its result to logical.
Similar functions like <code class="highlighter-rouge">pmap_dbl</code> return vectors of other types,
and many other tidyverse functions have strongly-typed variants as well.)</li>
  <li>Turn that logical vector into a single-column tibble,
giving that column the name “empty”.
We explain the use of <code class="highlighter-rouge">.</code> below.</li>
  <li>Add a second column with row numbers.</li>
  <li>Discard rows that aren’t empty.</li>
  <li>Return a vector of the remaining row IDs.</li>
</ol>

<blockquote>
  <p><strong>Wat?</strong></p>

  <p>Buried in the middle of the pipe shown above is the expression:</p>

  <p><code class="highlighter-rouge">tibble(empty = .)</code></p>

  <p>In this context, <code class="highlighter-rouge">.</code> means “whatever is on the left side of the <code class="highlighter-rouge">%&gt;%</code> operator”,
i.e., whatever would normally be passed as the first argument to this function.
Without this,
we have no easy way to give the sole column of our newly-constructed tibble a name.
This use of <code class="highlighter-rouge">.</code> takes advantage of a feature left over from the formula syntax
created in the early days of R’s predecessor, S;
in other contexts, <code class="highlighter-rouge">.</code> is just a very poorly named variable.</p>
</blockquote>

<p>Here’s our first batch of tests:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">tidyverse</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">testthat</span><span class="p">)</span><span class="w">
</span><span class="n">context</span><span class="p">(</span><span class="s2">"Finding empty rows"</span><span class="p">)</span><span class="w">

</span><span class="n">source</span><span class="p">(</span><span class="s2">"../scripts/find_empty_02.R"</span><span class="p">)</span><span class="w">

</span><span class="n">test_that</span><span class="p">(</span><span class="s2">"A single non-empty row is not mistakenly detected"</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">result</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">find_empty_rows</span><span class="p">(</span><span class="s2">"a\n1"</span><span class="p">)</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="kc">NULL</span><span class="p">)</span><span class="w">
</span><span class="p">})</span><span class="w">

</span><span class="n">test_that</span><span class="p">(</span><span class="s2">"Half-empty rows are not mistakenly detected"</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">result</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">find_empty_rows</span><span class="p">(</span><span class="s2">"a,b\n,2"</span><span class="p">)</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="kc">NULL</span><span class="p">)</span><span class="w">
</span><span class="p">})</span><span class="w">

</span><span class="n">test_that</span><span class="p">(</span><span class="s2">"An empty row in the middle is found"</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">result</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">find_empty_rows</span><span class="p">(</span><span class="s2">"a,b\n1,2\n,\n5,6"</span><span class="p">)</span><span class="w">
  </span><span class="n">expect_equal</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">2L</span><span class="p">))</span><span class="w">
</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>

<p>And here’s what happens when we run this file with <code class="highlighter-rouge">test_dir</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test_dir</span><span class="p">(</span><span class="s2">"tests"</span><span class="p">,</span><span class="w"> </span><span class="s2">"find_empty_a"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## ✔ | OK F W S | Context
## 
⠏ |  0       | Finding empty rows
⠋ |  0 1     | Finding empty rows
⠙ |  0 2     | Finding empty rows
⠹ |  1 2     | Finding empty rows
✖ |  1 2     | Finding empty rows
## ───────────────────────────────────────────────────────────────────────────
## test_find_empty_a.R:9: failure: A single non-empty row is not mistakenly detected
## `result` not equal to NULL.
## Types not compatible: integer is not NULL
## 
## test_find_empty_a.R:14: failure: Half-empty rows are not mistakenly detected
## `result` not equal to NULL.
## Types not compatible: integer is not NULL
## ───────────────────────────────────────────────────────────────────────────
## 
## ══ Results ════════════════════════════════════════════════════════════════
## OK:       1
## Failed:   2
## Warnings: 0
## Skipped:  0
</code></pre></div></div>

<p>This is perplexing:
we expected that if there were no empty rows,
our function would return <code class="highlighter-rouge">NULL</code>.
Let’s look more closely:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">find_empty_rows</span><span class="p">(</span><span class="s2">"a\n1"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## integer(0)
</code></pre></div></div>

<p>Ah:
we are being given an integer vector of zero length rather than <code class="highlighter-rouge">NULL</code>.
Let’s have a closer look at the properties of this strange beast:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">print</span><span class="p">(</span><span class="s2">"is integer(0) equal to NULL"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] "is integer(0) equal to NULL"
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">integer</span><span class="p">(</span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">NULL</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## logical(0)
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">print</span><span class="p">(</span><span class="s2">"any(logical(0))"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] "any(logical(0))"
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">any</span><span class="p">(</span><span class="n">logical</span><span class="p">(</span><span class="m">0</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] FALSE
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">print</span><span class="p">(</span><span class="s2">"all(logical(0))"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] "all(logical(0))"
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">all</span><span class="p">(</span><span class="n">logical</span><span class="p">(</span><span class="m">0</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] TRUE
</code></pre></div></div>

<p>All right.
If we compare <code class="highlighter-rouge">c(1L, 2L)</code> to <code class="highlighter-rouge">NULL</code>, we expect <code class="highlighter-rouge">c(FALSE, FALSE)</code>,
so it’s reasonable to get a zero-length logical vector as a result when we compare <code class="highlighter-rouge">NULL</code> to an integer vector with no elements.
The fact that <code class="highlighter-rouge">any</code> of an empty logical vector is <code class="highlighter-rouge">FALSE</code> isn’t really surprising either—none of the elements are <code class="highlighter-rouge">TRUE</code>,
so it would be hard to say that any of them are.
But <code class="highlighter-rouge">all</code> of an empty vector being <code class="highlighter-rouge">TRUE</code> is…unexpected.
The logic behind it is apparently that none of the (nonexistent) elements are <code class="highlighter-rouge">FALSE</code>,
but honestly,
at this point we are veering dangerously close to <a href="https://www.destroyallsoftware.com/talks/wat">JavaScript Logic</a>.
Speak not to me of madness, you who use languages designed by computer scientists.</p>


  </body>
</html>
