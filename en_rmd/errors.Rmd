---
title: "Handling Errors"
output: md_document
questions:
  - "How does R signal errors?"
  - "How can I handle errors myself?"
objectives:
  - "Name and describe the three levels of error handling in R."
  - "Handle an otherwise-fatal error in a function call in R."
keypoints:
  - "Operations signal conditions in R when errors occur."
  - "The three built-in levels of conditions are messages, warnings, and errors."
  - "Programs can signal these themselves using the functions `message`, `warning`, and `stop`."
  - "Operations can be placed in a call to the function `try` to suppress errors, but this is a bad idea."
  - "Operations can be placed in a call to the function `tryCatch` to handle errors."
---

```{r include=FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
knitr::opts_knit$set(base.url = "../")
knitr::opts_chunk$set(fig.path = "figures/errors/")
library(tidyverse)
```

Cautious programmers plan for the unexpected.
In Python,
this is done by [raising](../glossary/#raise-exception) and [catching](../glossary/#catch-exception) [exceptions](../glossary/#exception):

```{python}
values = [-1, 0, 1]
for i in range(4):
    try:
        reciprocal = 1/values[i]
        print("index {} value {} reciprocal {}".format(i, values[i], reciprocal))
    except ZeroDivisionError:
        print("index {} value {} ZeroDivisionError".format(i, values[i]))
    except Exception as e:
        print("index{} some other Exception: {}".format(i, e))
```

R draws on a different tradition.
We say that the operation [signals](../glossary/#signal-condition) a [condition](../glossary/#condition)
that some other piece of code then [handles](../glossary/#signal-handle).
These things are all simpler to do using the rlang library,
so we begin by loading that:

```{r include=FALSE}
library(rlang)
```

In order of increasing severity,
the three built-in kinds of conditions are [messages](../glossary/#message), [warnings](../glossary/#warning), and [errors](../glossary/#error).
(There are also interrupts, which are generated by the user pressing Ctrl-C to stop an operation, but we will ignore those.)
We can signal conditions of these three kinds using the functions `message`, `warning`, and `stop`,
each of which takes an error message as a parameter.

```{r error=TRUE}
message("This is a message.")
warning("This is a warning.\n")
stop("This is an error.")
```

Note that we have to supply our own line ending for warnings.
Note also that there are only a few situations in which a warning is appropriate:
if something has truly gone wrong,
we should stop,
and if it hasn't,
we should not distract users from more pressing concerns.

The bluntest of instruments for handling errors is to ignore them.
If a statement is wrapped in the function `try`,
errors that occur in it are still reported,
but execution continues.
Compare this:

```{r error=TRUE}
attemptWithoutTry <- function(left, right){
  temp <- left + right
  "result" # returned
}
result <- attemptWithoutTry(1, "two")
cat("result is", result)
```

with this:

```{r}
attemptUsingTry <- function(left, right){
  temp <- try(left + right)
  "value returned" # returned
}
result <- attemptUsingTry(1, "two")
cat("result is", result)
```

If we are *sure* that we wish to incur the risk of silent failure,
we can suppress error messages from `try`:

```{r}
attemptUsingTryQuietly <- function(left, right){
  temp <- try(left + right, silent = TRUE)
  "result" # returned
}
result <- attemptUsingTryQuietly(1, "two")
cat("result is", result)
```

Do not do this,
for it will one day leave you lost and gibbering in an incomprehensible silent hellscape.
Should you more sensibly wish to handle conditions rather than ignore them,
you may invoke `tryCatch`.
We begin by raising an error explicitly:

```{r}
tryCatch(
  stop("our message"),
  error = function(cnd) cat("error object is", as.character(cnd))
)
```

(We need to convert the error object `cnd` to character for printing because it is a list of two elements,
the message and the call,
but `cat` only handles character data.)
We can now run a function that would otherwise blow up:

```{r}
tryCatch(
  attemptWithoutTry(1, "two"),
  error = function(cnd) cat("error object is", as.character(cnd))
)
```

We can also handle non-fatal errors using `withCallingHandlers`,
and define new types of conditions,
but this is done less often in day-to-day R code than in Python:
see *[Advanced R][advanced-r]* for details,
or [this tutorial][said-handling-r-errors] by Omayma Said.

{% include links.md %}